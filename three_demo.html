<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/zlibjs@0.3.1/bin/inflate.dev.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/FBXLoader.js"></script>
    <!-- <script src="https://unpkg.com/three@0.102.0/src/math/Math.js" type="module"></script> -->
    <!-- <script src="https://unpkg.com/three@0.128.0/src/extras/PMREMGenerator.js" type="module"></script> -->
    <script src="classes\ModelLoader.js"></script>
    <script src="classes\BasicCharacterController.js"></script>
    <script src="classes\ThirdPersonCamera.js"></script>
    <script src="classes\Skybox.js"></script>
    <script src="classes\Ground.js"></script>
    <script src="classes\Water.js"></script>
</head>
<body>
    <script>
        (async () => {
            let sun = new THREE.Vector3();
            let scene = new THREE.Scene();
            let cameraHeight = 400;
            let cameraDepth = -120;
            let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, cameraHeight, cameraDepth);
            camera.rotation.y = Math.PI;
            camera.rotation.x = Math.PI / 8;

            let renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor('#e5e5e5');
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);


            let controls = new THREE.OrbitControls(camera, document.body);
            controls.addEventListener('change', renderer);

            let skybox = new Skybox();
            skybox.mesh.scale.setScalar(10000);
            scene.add(skybox.mesh);

            const skyUniforms = skybox.mesh.material.uniforms;

            skyUniforms[ 'turbidity' ].value = 10;
            skyUniforms[ 'rayleigh' ].value = 2;
            skyUniforms[ 'mieCoefficient' ].value = 0.005;
            skyUniforms[ 'mieDirectionalG' ].value = 0.8;

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            let ground = new Ground();
            await ground.init(null);
            scene.add(ground.mesh);

            let water = new Water();
            await water.init(null);
            scene.add(water.mesh);
            water.mesh.position.y = 45;
            water.mesh.position.x = 250;
            
            // let light = new THREE.PointLight(0x888888, 1, 1000);
            // light.position.set(0, 100, -100);
            // scene.add(light);
            const ambientLight = new THREE.AmbientLight(0xFFFFFF); // soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            scene.add( directionalLight );
            
            let modelLoader = new ModelLoader();
            let cottage = await modelLoader.loadModel('cottage');
            cottage.position.set(0, 40, 180);
            cottage.rotation.y = Math.PI / 1;
            scene.add(cottage);

            let workman = new BasicCharacterController();
            await workman.init();
            workman.setCollidableObjects([cottage]);
            
            scene.add(workman.model);

            let thirdPersonCamera = new ThirdPersonCamera(
                camera,
                workman.model
            );

            const cgeometry = new THREE.CylinderGeometry(5, 5, 20, 32);
            const cmaterial = new THREE.MeshNormalMaterial();
            this.cylinder = new THREE.Mesh( cgeometry, cmaterial );
            this.cylinder.position.y = 1000;
            const down = new THREE.Vector3(0.0, -1.0, 0.0);
            let arrow = null;
            let clock = new THREE.Clock();
            const parameters = {
                elevation: 2,
                azimuth: 180
            };
            // const pmremGenerator = new THREE.PMREMGenerator( renderer );

            let render = function() {
                //update sun
                const phi = THREE.Math.degToRad( 90 - parameters.elevation );
                const theta = THREE.Math.degToRad( parameters.azimuth );

                sun.setFromSphericalCoords( 1, phi, theta );

                skybox.mesh.material.uniforms[ 'sunPosition' ].value.copy( sun );
                // water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();

                // scene.environment = pmremGenerator.fromScene( skybox.mesh ).texture;
                //end update sun
                // water.mesh.position.y = workman.model.position.y;
                // console.log(workman.model.position.y);
                let delta = clock.getDelta();
                if (workman.mixer) {
                    workman.mixer.update(delta);
                }

                if (workman.north || workman.east || workman.south || workman.west) {
                    workman.run();
                } else {
                    workman.halt();
                }
                
                let ray = new THREE.Raycaster(cylinder.position, down.normalize(), 0, 2000);
                const intersects = ray.intersectObject(ground.mesh, true);
                if (intersects.length > 0) {
                    workman.model.position.y = intersects[0].point.y;
                    workman.cylinder.position.y = intersects[0].point.y;
                }
                
                if (workman.north && workman.west) {
                    workman.move(5.4, 0, 5.4);
                    workman.model.rotation.y = 1 * Math.PI / 4;
                } else if (workman.north && workman.east) {
                    workman.move(-5.4, 0, 5.4);
                    workman.model.rotation.y = 7 * Math.PI / 4;
                } else if (workman.south && workman.west) {
                    workman.move(5.4, 0, -5.4);
                    workman.model.rotation.y = 3 * Math.PI / 4;
                } else if (workman.south && workman.east) {
                    workman.move(-5.4, 0, -5.4);
                    workman.model.rotation.y = 5 * Math.PI / 4;
                } else if (workman.north) {
                    workman.move(0, 0, 5.4);
                    workman.model.rotation.y = 0 * Math.PI / 4;
                } else if (workman.west) {
                    workman.move(5.4, 0, 0);
                    workman.model.rotation.y = 2 * Math.PI / 4;
                } else if (workman.south) {
                    workman.move(0, 0, -5.4);
                    workman.model.rotation.y = 4 * Math.PI / 4;
                } else if (workman.east) {
                    workman.move(-5.4, 0, 0);
                    workman.model.rotation.y = 6 * Math.PI / 4;
                }

                if (workman.clockwise) {
                    workman.model.rotation.y += 0.1;
                } else if (workman.counterClockwise) {
                    workman.model.rotation.y -= 0.1;
                }

                cylinder.position.x = workman.model.position.x;
                cylinder.position.z = workman.model.position.z;
                
                for (let i = 0; i < workman.arrows.length; i++) {
                    scene.add(workman.arrows[i]);
                }
                workman.arrows = [];
                // thirdPersonCamera.update(cameraHeight, cameraDepth);
                // camera.lookAt(workman.model.position.x, workman.model.position.y, workman.model.position.z);
                
                setTimeout( function() {
                    requestAnimationFrame(render);
                }, 1000 / 60 );
                renderer.render(scene, camera);
            }

            render();
        })();

        

    </script>
</body>
</html>

