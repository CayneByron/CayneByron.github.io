<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/zlibjs@0.3.1/bin/inflate.dev.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="classes\ModelLoader.js"></script>
    <script src="classes\BasicCharacterController.js"></script>
    <script src="classes\ThirdPersonCamera.js"></script>
    <script src="classes\Skybox.js"></script>
    <script src="classes\Ground.js"></script>
</head>
<body>
    <script>
        (async () => {
            let scene = new THREE.Scene();

            let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1500);
            camera.position.set(0, 35, -80);
            camera.rotation.y = Math.PI;
            camera.rotation.x = Math.PI / 8;

            let renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor('#e5e5e5');
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);


            // let controls = new THREE.OrbitControls(camera, document.body);
            // controls.addEventListener('change', renderer);

            let skybox = new Skybox();
            scene.add(skybox.mesh);

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            let ground = new Ground();
            await ground.init(null);
            scene.add(ground.mesh);
            
            let light = new THREE.PointLight(0xFFFFFF, 1, 1000);
            light.position.set(0, 100, 0);
            scene.add(light);
            const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(ambientLight);
            
            let modelLoader = new ModelLoader();
            let cottage = await modelLoader.loadModel('cottage');
            cottage.position.set(0, 20, 180);
            cottage.rotation.y = Math.PI / 1;
            scene.add(cottage);

            let workman = new BasicCharacterController();
            await workman.init();
            workman.setCollidableObjects([cottage]);
            
            scene.add(workman.model);

            let thirdPersonCamera = new ThirdPersonCamera(
                camera,
                workman.model
            );

            const cgeometry = new THREE.CylinderGeometry(5, 5, 20, 32);
            const cmaterial = new THREE.MeshNormalMaterial();
            this.cylinder = new THREE.Mesh( cgeometry, cmaterial );
            this.cylinder.position.y = 100;
            const down = new THREE.Vector3(0.0, -1.0, 0.0);
            let arrow = null;
            let clock = new THREE.Clock();
            let render = function() {
                let delta = clock.getDelta();
                if (workman.mixer) {
                    workman.mixer.update(delta);
                }

                if (workman.north || workman.east || workman.south || workman.west) {
                    workman.run();
                } else {
                    workman.halt();
                }
                
                let ray = new THREE.Raycaster(cylinder.position, down.normalize(), 0, 200);
                const intersects = ray.intersectObject(ground.mesh, true);
                if (intersects.length > 0) {
                    workman.model.position.y = intersects[0].point.y;
                    workman.cylinder.position.y = intersects[0].point.y;
                }
                
                if (workman.north && workman.west) {
                    workman.move(1.9, 0, 1.9);
                    workman.model.rotation.y = 1 * Math.PI / 4;
                } else if (workman.north && workman.east) {
                    workman.move(-1.9, 0, 1.9);
                    workman.model.rotation.y = 7 * Math.PI / 4;
                } else if (workman.south && workman.west) {
                    workman.move(1.9, 0, -1.9);
                    workman.model.rotation.y = 3 * Math.PI / 4;
                } else if (workman.south && workman.east) {
                    workman.move(-1.9, 0, -1.9);
                    workman.model.rotation.y = 5 * Math.PI / 4;
                } else if (workman.north) {
                    workman.move(0, 0, 1.9);
                    workman.model.rotation.y = 0 * Math.PI / 4;
                } else if (workman.west) {
                    workman.move(1.9, 0, 0);
                    workman.model.rotation.y = 2 * Math.PI / 4;
                } else if (workman.south) {
                    workman.move(0, 0, -1.9);
                    workman.model.rotation.y = 4 * Math.PI / 4;
                } else if (workman.east) {
                    workman.move(-1.9, 0, 0);
                    workman.model.rotation.y = 6 * Math.PI / 4;
                }

                if (workman.clockwise) {
                    workman.model.rotation.y += 0.1;
                } else if (workman.counterClockwise) {
                    workman.model.rotation.y -= 0.1;
                }

                cylinder.position.x = workman.model.position.x;
                cylinder.position.z = workman.model.position.z;
                
                for (let i = 0; i < workman.arrows.length; i++) {
                    scene.add(workman.arrows[i]);
                }
                workman.arrows = [];
                thirdPersonCamera.update();
                // camera.lookAt(workman.model.position.x, workman.model.position.y, workman.model.position.z);
                
                setTimeout( function() {
                    requestAnimationFrame(render);
                }, 1000 / 60 );
                renderer.render(scene, camera);
            }

            render();
        })();

        

    </script>
</body>
</html>

