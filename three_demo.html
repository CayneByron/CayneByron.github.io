<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/zlibjs@0.3.1/bin/inflate.dev.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.102.0/examples/js/loaders/FBXLoader.js"></script>
</head>
<body>
    <script>
        class ModelLoader {
            constructor() {

            }
            async loadModel(name) {
                let model = new Promise(function(myResolve, myReject) {
                    const fbxLoader = new THREE.FBXLoader();
                    fbxLoader.setPath('game_assets\\models\\');
                    fbxLoader.load(name + '.fbx', (fbx) => {
                        fbx.scale.setScalar(0.1);
                        fbx.traverse(c => {
                            c.castShadow = true;
                        });
                        myResolve(fbx);
                    });
                });

                return model;
            }

            detectCollision(player, collidableMeshList) {
                let hasRun = false;
                let cottage = collidableMeshList[0];
                player.traverseVisible(child => {
                    if (child.isMesh && child.geometry.isBufferGeometry) {
                        child.geometry.computeBoundingSphere();
                        cottage.traverseVisible(c_child => {
                            if (c_child.isMesh && c_child.geometry.isBufferGeometry) {
                                c_child.geometry.computeBoundingSphere();
                                if (c_child.geometry.boundingSphere.intersectsSphere(child.geometry.boundingSphere)) {
                                    // console.log('CRASH!');
                                }
                            }
                        });
                    }
                });
            }
        }

        class BasicCharacterController {
            constructor() {
                
            }

            async init() {
                this.model = await this.loadModel('workman');
                this.animations = [];
                this.animations['running'] = await this.loadAnimation('Jogging');
                this.animations['idle'] = await this.loadAnimation('Breathing Idle');
                this.mixer = new THREE.AnimationMixer(this.model);
                this.running = this.mixer.clipAction(this.animations['running'].animations[0]);
                this.idle = this.mixer.clipAction(this.animations['idle'].animations[0]);

                this.north = false;
                this.west = false;
                this.south = false;
                this.east = false;
                this.northWest = false;
                this.northEast = false;
                this.southWest = false;
                this.southEast = false;
                this.setKeyControls();
            };

            async loadModel(name) {
                let model = new Promise(function(myResolve, myReject) {
                    const fbxLoader = new THREE.FBXLoader();
                    fbxLoader.setPath('game_assets\\models\\');
                    fbxLoader.load(name + '.fbx', (fbx) => {
                        fbx.scale.setScalar(0.1);
                        fbx.traverse(c => {
                            c.castShadow = true;
                        })
                        myResolve(fbx);
                    });
                });

                return model;
            }

            async loadAnimation(name) {
                let animation = new Promise(function(myResolve, myReject) {
                    const anim = new THREE.FBXLoader();
                    anim.setPath('game_assets\\animations\\');
                    anim.load(name + '.fbx', (anim) => {
                        myResolve(anim);
                    });
                });

                return animation;
            }

            move(x, y, z) {
                this.model.position.x += x;
                this.model.position.y += y;
                this.model.position.z += z;
            }

            run() {
                this.running.play();
                this.idle.stop();
            }

            halt() {
                this.idle.play();
                this.running.stop();
            }

            setKeyControls() {
                document.addEventListener('keypress', (e) => {
                    if (e.code === "KeyW"){
                        this.north = true;
                    } 
                    if (e.code === "KeyA") { 
                        this.west = true;
                    } 
                    if (e.code === "KeyS") { 
                        this.south = true;
                    } 
                    if (e.code === "KeyD") { 
                        this.east = true;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.code === "KeyW"){
                        this.north = false;
                    } 
                    if (e.code === "KeyA") { 
                        this.west = false;
                    } 
                    if (e.code === "KeyS") { 
                        this.south = false;
                    } 
                    if (e.code === "KeyD") { 
                        this.east = false;
                    }
                });
            }
        }

        class ThirdPersonCamera {
            constructor(camera, target) {
                this.camera = camera;
                this.target = target;
                this.currentPosition = new THREE.Vector3();
                this.currentLookAt = new THREE.Vector3();
            }

            update(timeElapsed) {
                this.camera.position.set(this.target.position.x, 35, this.target.position.z - 80);
            }
        }

        (async () => {
            let scene = new THREE.Scene();

            let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 35, -80);
            camera.rotation.y = Math.PI;
            camera.rotation.x = Math.PI / 8;

            let renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor('#e5e5e5');
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // let controls = new THREE.OrbitControls(camera, document.body);
            // controls.addEventListener('change', renderer);

            let materialArray = [];
            let texture_ft = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_Front.bmp');
            let texture_bk = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_Back.bmp');
            let texture_up = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_TopR270.bmp');
            let texture_dn = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_Bottom.bmp');
            let texture_rt = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_Left.bmp');
            let texture_lf = new THREE.TextureLoader().load('game_assets\\skybox\\Daylight Box_Pieces\\Daylight Box_Right.bmp');

            materialArray.push(new THREE.MeshBasicMaterial({map: texture_ft}));
            materialArray.push(new THREE.MeshBasicMaterial({map: texture_bk}));
            materialArray.push(new THREE.MeshBasicMaterial({map: texture_up}));
            materialArray.push(new THREE.MeshBasicMaterial({map: texture_dn}));
            materialArray.push(new THREE.MeshBasicMaterial({map: texture_rt}));
            materialArray.push(new THREE.MeshBasicMaterial({map: texture_lf}));

            for (let i = 0; i < materialArray.length; i++) {
                materialArray[i].side = THREE.BackSide;
            }

            let skyboxGeo = new THREE.BoxGeometry(1000, 1000, 1000);
            let skybox = new THREE.Mesh(skyboxGeo, materialArray);
            scene.add(skybox);

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });

            const geometry = new THREE.PlaneGeometry(1000, 1000);
            const ground = new THREE.TextureLoader().load('game_assets\\brown-grunge-texture.jpg');
            const material = new THREE.MeshBasicMaterial({color: 0x888888, side: THREE.DoubleSide, map: ground});
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = Math.PI / 2;

            scene.add(plane);

            // let raycaster = new THREE.Raycaster();
            // let mouse = new THREE.Vector2();

            let light = new THREE.PointLight(0xFFFFFF, 1, 1000);
            light.position.set(0, 100, 0);
            scene.add(light);
            const ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
            scene.add(ambientLight);

            // const loader = new THREE.GLTFLoader();
            // loader.load('Atlas_V_401.glb', (gltf => {
            //     let rocket = gltf.scene;
            //     rocket.traverse(c => {
            //         c.castShadow = true;
            //     });
            //     rocket.position.y = 30;
            //     rocket.rotation.y = Math.PI;
            //     scene.add(gltf.scene);
            // }));

            let modelLoader = new ModelLoader();
            let cottage = await modelLoader.loadModel('cottage');
            cottage.position.set(100, 0, 100);
            scene.add(cottage);

            let workman = new BasicCharacterController();
            await workman.init();

            scene.add(workman.model);

            let thirdPersonCamera = new ThirdPersonCamera(
                camera,
                workman.model
            );

            // cottage.traverseVisible(c_child => {
            //     if (c_child.isMesh && c_child.geometry.isBufferGeometry) {
            //         console.log(c_child.geometry);
            //         // c_child.geometry.computeBoundingSphere();
            //         // c_child.geometry.computeBoundingBox();
            //         // let boundingSphere = c_child.geometry.boundingSphere;
            //         // let boundingBox = c_child.geometry.boundingBox;
            //         // console.log(boundingSphere);
            //         // console.log(boundingBox);
            //         // // if (c_child.geometry.boundingSphere.intersectsSphere(child.geometry.boundingSphere)) {
            //         // //     // console.log('CRASH!');
            //         // // }
            //         // var sphereGeometry = new THREE.SphereGeometry(boundingSphere.radius, 50, 50);
            //         // var sphereMaterial = new THREE.MeshNormalMaterial();
            //         // var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            //         // // sphere.position = boundingSphere.center;
            //         // scene.add(sphere);
            //     }
            // });

            // var box = new THREE.Box3().setFromObject( cottage );
            // console.log( box.min, box.max, box.getSize() );

            // const box1 = new THREE.Box3();

            // const mesh1 = new THREE.Mesh(
            //     new THREE.SphereGeometry(),
            //     new THREE.MeshNormalMaterial()
            // );
            // scene.add(mesh1);
            // // ensure the bounding box is computed for its geometry
            // // this should be done only once (assuming static geometries)
            // mesh1.geometry.computeBoundingBox();
            
            const sphere = new THREE.SphereGeometry();
            const object = new THREE.Mesh( sphere, new THREE.MeshNormalMaterial());
            const box = new THREE.BoxHelper( cottage, 0xffff00 );
            scene.add( box );
            console.log(box)

            modelLoader.detectCollision(workman.model, [cottage]);
            let clock = new THREE.Clock();
            let render = function() {
                // box1.copy( mesh1.geometry.boundingBox ).applyMatrix4( mesh1.matrixWorld );
                // console.log(box1);

                let delta = clock.getDelta();
                if (workman.mixer) {
                    workman.mixer.update(delta);
                }

                if (workman.north || workman.east || workman.south || workman.west) {
                    workman.run();
                } else {
                    workman.halt();
                }

                // modelLoader.detectCollision(workman.model, [cottage]);
                if (workman.north && workman.west) {
                    workman.move(1.8, 0, 1.8);
                    workman.model.rotation.y = 1 * Math.PI / 4;
                } else if (workman.north && workman.east) {
                    workman.move(-1.8, 0, 1.8);
                    workman.model.rotation.y = 7 * Math.PI / 4;
                } else if (workman.south && workman.west) {
                    workman.move(1.8, 0, -1.8);
                    workman.model.rotation.y = 3 * Math.PI / 4;
                } else if (workman.south && workman.east) {
                    workman.move(-1.8, 0, -1.8);
                    workman.model.rotation.y = 5 * Math.PI / 4;
                } else if (workman.north) {
                    workman.move(0, 0, 1.8);
                    workman.model.rotation.y = 0 * Math.PI / 4;
                } else if (workman.west) {
                    workman.move(1.8, 0, 0);
                    workman.model.rotation.y = 2 * Math.PI / 4;
                } else if (workman.south) {
                    workman.move(0, 0, -1.8);
                    workman.model.rotation.y = 4 * Math.PI / 4;
                } else if (workman.east) {
                    workman.move(-1.8, 0, 0);
                    workman.model.rotation.y = 6 * Math.PI / 4;
                }

                thirdPersonCamera.update(delta);
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }

            render();
        })();

        

    </script>
</body>
</html>

